#!/bin/bash

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-n|--namespace NAMESPACE] -g|--group GROUP [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -u|--update SUBJECT [-C|--keep-context|-c|--context CONTEXT|-] [-t|--timestamp EPOCH]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -d|--diff SUBJECT [-f|--fallback-subject FALLBACK-SUBJECT]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -q|--query SUBJECT [-w|--within VALID-TIMESPAN-SECONDS] [-x|--get-context] [-f|--fallback-subject FALLBACK-SUBJECT]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Records (and later retrieves) the (time of the) execution of a command (with an
optional CONTEXT).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --namespace|-n NAMESPACE	Optional application / use case for this tool's
				use. Determines the configuration directory.
    --group|-g GROUP		Category in the context of the application.
				Determines the configuration file.
    --update|-u SUBJECT		Record the execution time of SUBJECT.
    --context|-c CONTEXT|-	Optional context for SUBJECT, e.g. the command's
				exit status, or command output (can be
				multi-line). With -, this is read from standard
				input.
    --keep-context|-C		Just update the execution time, but keep the
				existing context from the prior run.
    --timestamp|-t EPOCH	Write EPOCH instead of the current time.
				(For other actions, use EPOCH instead of now for
				comparison.)
    --diff|-d SUBJECT		Determine the time difference between the last
				execution of SUBJECT and now. Returns 4 if no
				record for SUBJECT exists.
    --query|-q SUBJECT		Query whether a record for SUBJECT exists.
    --within|-w VALID-TIMESPAN-SECONDS
				Checks whether the time difference between the
				last execution of SUBJECT and now is smaller or
				equal to VALID-TIMESPAN-SECONDS. Returns 1 if it
				is larger or 4 if no record for SUBJECT exists.
    --get-context|-x		Prints the recorded CONTEXT for SUBJECT (if it
				exists).
    --fallback-subject|-f FALLBACK-SUBJECT
				Lookup FALLBACK-SUBJECT instead if SUBJECT
				hasn't been recorded.
HELPTEXT
}

multipleActionsError()
{
    echo >&2 "ERROR: Only one of --update, --diff --query allowed."
    echo >&2
    printShortUsage "$1" >&2
    exit 2
}
now="$(date +%s)"
namespace=
group=
subject=
fallbackSubject=
context=
isKeepContext=
action=
isGetContext=
validTimespanInSeconds=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--namespace|-n)	shift; namespace="$1"; shift;;
	--group|-g)	shift; group="$1"; shift;;
	--context|-c)	shift
			if [ "$1" = '-' ]; then
			    context="$(< /dev/stdin)"
			else
			    context="$1"
			fi
			shift
			;;
	--keep-context|-C)	shift; isKeepContext=t;;
	--timestamp|-t)	shift; now="$1"; shift;;
	--get-context|-x)	shift; isGetContext=t;;
	--fallback-subject|-f)	shift; fallbackSubject="$1"; shift;;
	--within|-w)	shift; validTimespanInSeconds="$1"; shift;;
	--update|-u)	shift; [ "$action" ] && multipleActionsError "$0"; action='update'; subject="$1"; shift;;
	--diff|-d)	shift; [ "$action" ] && multipleActionsError "$0"; action='timediff'; subject="$1"; shift;;
	--query|-q)	shift; [ "$action" ] && multipleActionsError "$0"; action='query'; subject="$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
for parameter in action group subject
do
    if [ -z "${!parameter}" ]; then
	echo >&2 "ERROR: No $parameter passed."
	echo >&2
	printShortUsage "$0" >&2
	exit 2
    fi
done
if [ $# -gt 0 ]; then
    printShortUsage "$0" >&2
    exit 2
fi
if [ "$validTimespanInSeconds" ]; then
    if [ "$action" = 'query' ]; then
	action='within'
    else
	echo >&2 "ERROR: --within can only be combined with --query"
	echo >&2
	printShortUsage "$0" >&2
	exit 2
    fi
fi

database()
{
    miniDB --namespace "$namespace" --table "$group" "$@"
}

writeMarker()
{
    database --schema 'SUBJECT TIMESTAMP CONTEXT' --update "$subject	$now	$context"
}

readMarker()
{
    line="$(database --query "$subject" ${fallbackSubject:+--fallback "$fallbackSubject"} --columns \*)"
    [ "$line" ] || return 1

    markerTimestamp="${line%%	*}"
    markerContext="${line#*	}"
}

printContext()
{
    if [ "$isGetContext" ]; then
	printf '%s\n' "$markerContext"
    fi
}


update()
{
    if [ "$isKeepContext" ]; then
	readMarker
	context="$markerContext"
    fi

    writeMarker
}

timediff()
{
    if [ "$isGetContext" ]; then
	echo >&2 'ERROR: Cannot query context with --diff.'
	echo >&2
	printShortUsage "$0" >&2
	return 2
    fi

    readMarker || return 4

    printf '%d\n' "$((now - markerTimestamp))"
}

query()
{
    readMarker || return $?
    printContext
}

within()
{
    readMarker || return 4
    printContext

    [ $markerTimestamp -ge $((now - validTimespanInSeconds)) ]
}


"$action"
